import Foundation

/// Represents the complete dnsmasq configuration
struct DnsmasqConfig {
    var dnsRecords: [DNSRecord] = []
    var dhcpLeases: [DHCPLease] = []
    var rawLines: [ConfigLine] = []

    /// Represents a line in the config file
    struct ConfigLine {
        var lineNumber: Int
        var content: String
        var type: LineType

        enum LineType {
            case comment
            case empty
            case dnsRecord
            case dhcpRange
            case dhcpHost
            case dhcpOption
            case other
        }
    }

    /// Parse configuration from file content
    static func parse(from content: String) -> DnsmasqConfig {
        var config = DnsmasqConfig()
        let lines = content.components(separatedBy: .newlines)

        for (index, line) in lines.enumerated() {
            let trimmed = line.trimmingCharacters(in: .whitespaces)

            // Determine line type and parse
            let lineType: ConfigLine.LineType

            if trimmed.isEmpty {
                lineType = .empty
            } else if trimmed.hasPrefix("#") {
                lineType = .comment
            } else if let dnsRecord = DNSRecord.fromConfigLine(trimmed) {
                lineType = .dnsRecord
                config.dnsRecords.append(dnsRecord)
            } else if let dhcpRange = DHCPRange.fromConfigLine(trimmed) {
                lineType = .dhcpRange
                config.dhcpLeases.append(DHCPLease(entryType: .range(dhcpRange)))
            } else if let dhcpHost = DHCPHost.fromConfigLine(trimmed) {
                lineType = .dhcpHost
                config.dhcpLeases.append(DHCPLease(entryType: .host(dhcpHost)))
            } else if let dhcpOption = DHCPOption.fromConfigLine(trimmed) {
                lineType = .dhcpOption
                config.dhcpLeases.append(DHCPLease(entryType: .option(dhcpOption)))
            } else {
                lineType = .other
            }

            config.rawLines.append(ConfigLine(lineNumber: index + 1, content: line, type: lineType))
        }

        return config
    }

    /// Generate configuration file content
    func toConfigString() -> String {
        var lines: [String] = []
        var processedDNS = Set<UUID>()
        var processedDHCP = Set<UUID>()

        // Process raw lines, replacing parsed entries with updated versions
        for rawLine in rawLines {
            switch rawLine.type {
            case .dnsRecord:
                // Find matching DNS record by parsing the original line
                if let original = DNSRecord.fromConfigLine(rawLine.content),
                   let updated = dnsRecords.first(where: { $0.domain == original.domain && $0.recordType == original.recordType && !processedDNS.contains($0.id) }) {
                    lines.append(updated.toConfigLine())
                    processedDNS.insert(updated.id)
                } else {
                    lines.append(rawLine.content)
                }

            case .dhcpRange, .dhcpHost, .dhcpOption:
                // Keep original for now, will handle updates separately
                lines.append(rawLine.content)

            default:
                lines.append(rawLine.content)
            }
        }

        // Append new DNS records that weren't in the original file
        for record in dnsRecords where !processedDNS.contains(record.id) {
            lines.append(record.toConfigLine())
        }

        return lines.joined(separator: "\n")
    }

    /// Generate a clean config with just the managed entries
    func toCleanConfigString() -> String {
        var sections: [String] = []

        // Header
        sections.append("# dnsmasq configuration")
        sections.append("# Generated by dnsmasqGUI")
        sections.append("")

        // DNS Records
        if !dnsRecords.isEmpty {
            sections.append("# DNS Configuration")
            for record in dnsRecords {
                sections.append(record.toConfigLine())
            }
            sections.append("")
        }

        // DHCP Configuration
        let ranges = dhcpLeases.compactMap { lease -> DHCPRange? in
            if case .range(let range) = lease.entryType { return range }
            return nil
        }
        let hosts = dhcpLeases.compactMap { lease -> DHCPHost? in
            if case .host(let host) = lease.entryType { return host }
            return nil
        }
        let options = dhcpLeases.compactMap { lease -> DHCPOption? in
            if case .option(let opt) = lease.entryType { return opt }
            return nil
        }

        if !ranges.isEmpty || !hosts.isEmpty || !options.isEmpty {
            sections.append("# DHCP Configuration")

            for range in ranges {
                sections.append(range.toConfigLine())
            }

            for option in options {
                sections.append(option.toConfigLine())
            }

            if !hosts.isEmpty {
                sections.append("")
                sections.append("# Static DHCP Hosts")
                for host in hosts {
                    sections.append(host.toConfigLine())
                }
            }
        }

        return sections.joined(separator: "\n")
    }
}
